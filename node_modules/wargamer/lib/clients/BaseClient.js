'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _staleLruCache = require('stale-lru-cache');

var _staleLruCache2 = _interopRequireDefault(_staleLruCache);

var _superagent = require('superagent');

var _superagent2 = _interopRequireDefault(_superagent);

var _APIError = require('../errors/APIError');

var _APIError2 = _interopRequireDefault(_APIError);

var _APIResponse = require('../responses/APIResponse');

var _APIResponse2 = _interopRequireDefault(_APIResponse);

var _Authentication = require('../modules/common/Authentication');

var _Authentication2 = _interopRequireDefault(_Authentication);

var _RequestError = require('../errors/RequestError');

var _RequestError2 = _interopRequireDefault(_RequestError);

var _hashCode = require('../utils/hashCode');

var _hashCode2 = _interopRequireDefault(_hashCode);

var _mapValues = require('../utils/mapValues');

var _mapValues2 = _interopRequireDefault(_mapValues);

var _sortObjectByKey = require('../utils/sortObjectByKey');

var _sortObjectByKey2 = _interopRequireDefault(_sortObjectByKey);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * The options available to use on a client constructor.
 * @typedef {Object} ClientOptions
 * @property {string} realm - The realm/region this client is for.
 * @property {string} applicationId - The application ID of this client.
 * @property {string} [accessToken=null] - The access token for this client,
 *   if it will be using one.
 * @param {string} [language=null] - The default localization language
 *   to use for API responses.
 * @param {?number} [options.cacheTimeToLive=600] - The time to live in seconds
 *   for the client's data cache entries. `null` if no there is no TTL.
 * @param {?number} [options.cacheMaxSize=250] - The max number of entries in
 *   the client's data cache.
 */

/**
 * The options available to use when making a single request.
 * @typedef {Object} RequestOptions
 * @property {string} [type] - The API to send this request to. One of: `wot`,
 *   `wotb`, `wotx`, `wows`, `wowp`, `wgn`.
 * @property {string} [realm] - The realm/region to use for the request.
 *   One of: `ru`, `eu`, `na`, `kr`, `asia`, `xbox`, `ps4`.
 */

/**
 * Mapping between realms and their TLDs.
 * @type {Object}
 * @constant
 * @private
 */
var REALM_TLD = {
  ru: 'ru',
  eu: 'eu',
  na: 'com',
  kr: 'kr',
  asia: 'asia',
  xbox: 'xbox',
  ps4: 'ps4'
};

/**
 * Functions which generate the base URIs for various APIs.
 * @type {Object}
 * @constant
 * @private
 */
var BASE_URI = {
  wot: function wot(realm) {
    return `https://api.worldoftanks.${REALM_TLD[realm]}/wot`;
  },
  wotb: function wotb(realm) {
    return `https://api.wotblitz.${REALM_TLD[realm]}/wotb`;
  },
  wotx: function wotx(realm) {
    return `https://api-${REALM_TLD[realm]}-console.worldoftanks.com/wotx`;
  },
  wows: function wows(realm) {
    return `https://api.worldofwarships.${REALM_TLD[realm]}/wows`;
  },
  wowp: function wowp(realm) {
    return `https://api.worldofwarplanes.${REALM_TLD[realm]}/wowp`;
  },
  wgn: function wgn(realm) {
    return `https://api.worldoftanks.${REALM_TLD[realm]}/wgn`;
  }
};

/**
 * Returns the base URI for a given realm and API type.
 * @param {string} realm - The realm/region of the server.
 * @param {string} type - The desired API.
 * @returns {string} The base URI for the API that was specified.
 * @throws {Error} Thrown if the given `realm` or `type` don't exist.
 * @private
 */
var getBaseUri = function getBaseUri(realm, type) {
  if (!REALM_TLD[realm] || !BASE_URI[type]) {
    throw new Error('Unknown realm or type given.');
  }

  return BASE_URI[type](realm);
};

/**
 * @classdesc The base API client.
 */

var BaseClient = function () {
  /**
   * Constructor.
   * @param {Object} options - The client options.
   * @param {string} options.type - The type of API this client is for.
   * @param {string} options.realm - The realm/region this client is for.
   * @param {string} options.applicationId - The application ID of this client.
   * @param {string} [options.accessToken=null] - The access token for this
   *   client, if it will be using one.
   * @param {string} [options.language=null] - The default localization language
   *   to use for API responses.
   * @param {?number} [options.cacheTimeToLive=600] - The time to live in seconds
   *   for the client's data cache entries. `null` if no there is no TTL.
   * @param {?number} [options.cacheMaxSize=250] - The max number of entries in
   *   the client's data cache.
   * @throws {TypeError} Thrown if options are not well-formed.
   */
  function BaseClient(options) {
    _classCallCheck(this, BaseClient);

    /**
     * The default time to live for cache entries, in seconds.
     * @type {number}
     * @static
     * @const
     * @private
     */
    this.constructor.DEFAULT_CACHE_TTL = 600;

    /**
     * The default size of the cache.
     * @type {number}
     * @static
     * @const
     * @private
     */
    this.constructor.DEFAULT_CACHE_SIZE = 250;

    var type = options.type,
        realm = options.realm,
        applicationId = options.applicationId,
        _options$accessToken = options.accessToken,
        accessToken = _options$accessToken === undefined ? null : _options$accessToken,
        _options$language = options.language,
        language = _options$language === undefined ? null : _options$language,
        _options$cacheTimeToL = options.cacheTimeToLive,
        cacheTimeToLive = _options$cacheTimeToL === undefined ? this.constructor.DEFAULT_CACHE_TTL : _options$cacheTimeToL,
        _options$cacheMaxSize = options.cacheMaxSize,
        cacheMaxSize = _options$cacheMaxSize === undefined ? this.constructor.DEFAULT_CACHE_SIZE : _options$cacheMaxSize;


    if (typeof realm !== 'string' || !REALM_TLD[realm.toLowerCase()]) {
      throw new TypeError('Must specify a valid realm for the client.');
    } else if (typeof applicationId !== 'string') {
      throw new TypeError('Must specify an application ID for the client.');
    }

    var normalizedRealm = realm.toLowerCase();

    /**
     * The type of API this client is for.
     * @type {string}
     */
    this.type = type;

    /**
     * The realm, i.e. region of this client.
     * @type {string}
     */
    this.realm = normalizedRealm;

    /**
     * The application ID for this client.
     * @type {string}
     */
    this.applicationId = applicationId;

    /**
     * The access token for this client.
     * @type {?string}
     */
    this.accessToken = accessToken;

    /**
     * The default localization language for this client.
     * @type {?string}
     */
    this.language = language;

    /**
     * The client's Authentication module.
     * @type {Authentication}
     */
    this.authentication = new _Authentication2.default(this);

    /**
     * The base API URI for this client.
     * @type {string}
     * @private
     */
    this.baseUri = getBaseUri(normalizedRealm, type);

    /**
     * The API response cache.
     * @type {Cache}
     * @private
     */
    this.cache = new _staleLruCache2.default({
      maxAge: cacheTimeToLive,
      staleWhileRevalidate: 300,
      maxSize: cacheMaxSize
    });
  }

  /**
   * Normalizes a given parameter type so the API can consume it.
   * @param {*} parameter - The parameter to normalize.
   * @returns {*} The normalized parameter.
   * @static
   * @private
   */


  _createClass(BaseClient, [{
    key: 'get',


    /**
     * Sends a GET request to the API.
     * @param {string} method - The method to request.
     * @param {Object} [params={}] - The parameters to include in the request.
     * @param {RequestOptions} [options={}] - Options used to override client defaults.
     * @returns {Promise.<APIResponse, Error>} Returns a promise resolving to the
     *   returned API data, or rejecting with an error.
     */
    value: function get(method) {
      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      return this.request(method, params, _extends({}, options, { method: 'GET' }));
    }

    /**
     * Sends a POST request to the API.
     * @param {string} method - The method to request.
     * @param {Object} [params={}] - The parameters to include in the request.
     * @param {RequestOptions} [options={}] - Options used to override client defaults.
     * @returns {Promise.<APIResponse, Error>} Returns a promise resolving to the
     *   returned API data, or rejecting with an error.
     */

  }, {
    key: 'post',
    value: function post(method) {
      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      return this.request(method, params, _extends({}, options, { method: 'POST' }));
    }

    /**
     * Fetches data from an endpoint method.
     * @param {string} apiMethod - The method to request.
     * @param {Object} [params={}] - The parameters to include in the request.
     * @param {RequestOptions} [options={}] - Options used to override client defaults.
     * @returns {Promise.<APIResponse, Error>} Returns a promise resolving to the
     *   returned API data, or rejecting with an error.
     * @private
     */

  }, {
    key: 'request',
    value: function request(apiMethod) {
      var _this = this;

      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      return new Promise(function (resolve) {
        var _options$type = options.type,
            type = _options$type === undefined ? _this.type : _options$type,
            _options$realm = options.realm,
            realm = _options$realm === undefined ? _this.realm : _options$realm,
            _options$method = options.method,
            method = _options$method === undefined ? 'GET' : _options$method;


        if (typeof apiMethod !== 'string') {
          throw new TypeError('Expected API method to be a string.');
        }

        var normalizedApiMethod = apiMethod.toLowerCase();
        var normalizedRealm = realm.toLowerCase();

        // construct the request URL
        var baseUrl = normalizedRealm === _this.realm ? _this.baseUri : getBaseUri(normalizedRealm, type);
        var requestUrl = `${baseUrl}/${normalizedApiMethod.replace(/^\/*(.+?)\/*$/, '$1')}/`;

        // construct the payload
        var payload = _extends({
          application_id: _this.applicationId,
          access_token: _this.accessToken,
          language: _this.language
        }, params);

        var normalizedPayload = (0, _mapValues2.default)(payload, _this.constructor.normalizeParameterValue);

        // compute information for the cache

        var application_id = normalizedPayload.application_id,
            rest = _objectWithoutProperties(normalizedPayload, ['application_id']); // eslint-disable-line no-unused-vars


        var cacheKey = (0, _hashCode2.default)(`${requestUrl}${JSON.stringify((0, _sortObjectByKey2.default)(rest))}`);

        var fulfillResponse = function fulfillResponse(response) {
          var _response$body$error = response.body.error,
              error = _response$body$error === undefined ? null : _response$body$error;


          if (error) {
            // Wargaming API error
            throw new _APIError2.default({
              client: _this,
              statusCode: response.status,
              method: normalizedApiMethod,
              error
            });
          }

          return new _APIResponse2.default({
            client: _this,
            requestRealm: normalizedRealm,
            method: normalizedApiMethod,
            body: response.body
          });
        };

        var rejectResponse = function rejectResponse(value) {
          // check if this is a HTTP error or a Wargaming error
          if (value instanceof Error) {
            throw value;
          }

          var error = value.response.error;


          throw new _RequestError2.default({
            message: value.body.error.message,
            client: _this,
            statusCode: error.status
          });
        };

        if (method === 'GET') {
          var cached = _this.cache.get(cacheKey);

          if (cached) {
            var response = new _APIResponse2.default({
              client: _this,
              requestRealm: normalizedRealm,
              method: normalizedApiMethod,
              body: cached
            });

            resolve(response);
          }

          var promise = _superagent2.default.get(requestUrl).query(normalizedPayload).then(fulfillResponse).then(function (apiResponse) {
            _this.cache.set(cacheKey, apiResponse.body, {
              revalidate: function revalidate(key, callback) {
                _this.request(apiMethod, params, options).then(function (revalidateResponse) {
                  callback(null, revalidateResponse.body);
                }).catch(callback);
              }
            });

            return apiResponse;
          }).catch(rejectResponse);

          resolve(promise);
        } else if (method === 'POST') {
          var _promise = _superagent2.default.post(requestUrl).type('form').send(normalizedPayload).then(fulfillResponse).catch(rejectResponse);

          resolve(_promise);
        }

        // we should never get here
        throw new Error('Received invalid request method.');
      });
    }
  }], [{
    key: 'normalizeParameterValue',
    value: function normalizeParameterValue(parameter) {
      if (Array.isArray(parameter)) {
        return parameter.join(',');
      } else if (parameter instanceof Date) {
        return parameter.toISOString();
      }

      return parameter;
    }
  }]);

  return BaseClient;
}();

exports.default = BaseClient;