'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

/**
 * Searches for an entry in the encyclopedia endpoint for an API.
 * @param {Object} params - The parameters for the search.
 * @param {(number|string)} params.identifier - The entry identifier to use for lookup.
 * If a number is supplied, it is treated as the entry's ID.
 * If a string is supplied, the identifier is matched against entry names with
 *   the closest match being selected.
 * @param {string} params.indexEndpoint - The endpoint to use for indexing entries.
 * @param {string} params.dataEndpoint - The endpoint to use for returning entry
 *   data.
 * @param {string} params.identifierKey - The key which identifies entries.
 * @param {Fuse} params.fuse - The Fuse object to use for matching against indexed
 *   entries.
 * @param {Array.<string>} params.searchFields - The fields to request when hitting
 *   the `indexEndpoint`. The `identifierKey` will automatically be appended to
 *   this array.
 * @returns {Promise.<?Object, Error>} A promise resolving to the data for the
 *   matched entry, or `null` if no entries were matched.
 * @this {ClientModule}
 * @private
 */
var resolveEntry = exports.resolveEntry = function resolveEntry(params) {
  var _this = this;

  var identifier = params.identifier,
      indexEndpoint = params.indexEndpoint,
      dataEndpoint = params.dataEndpoint,
      identifierKey = params.identifierKey,
      fuse = params.fuse,
      searchFields = params.searchFields;


  if (typeof identifier === 'number') {
    return this.client.get(dataEndpoint, { [identifierKey]: identifier }).then(function (response) {
      return response.data[identifier];
    });
  } else if (typeof identifier === 'string') {
    return this.client.get(indexEndpoint, { fields: [].concat(_toConsumableArray(searchFields), [identifierKey]) }).then(function (response) {
      var entries = response.data;

      fuse.set(Object.keys(entries).reduce(function (accumulated, next) {
        return [].concat(_toConsumableArray(accumulated), [entries[next]]);
      }, []));

      var results = fuse.search(identifier);

      if (!results.length) {
        return null;
      }

      var _results = _slicedToArray(results, 1),
          matchedId = _results[0][identifierKey];

      return Promise.all([matchedId, _this.client.get(dataEndpoint, { [identifierKey]: matchedId })]);
    }).then(function (_ref) {
      var _ref2 = _slicedToArray(_ref, 2),
          matchedId = _ref2[0],
          response = _ref2[1];

      return response.data[matchedId];
    });
  }

  return Promise.reject(new TypeError('Expected a string or number as the entry identifier.'));
};

/**
 * Extracts the top modules of each type from a given module tree. The modules
 *   with the highest experience cost are considered the 'top' modules.
 * @param {Object} moduleTree - The module tree.
 * @returns {Object} An object containing the top modules of each type found in
 *   the module tree. The module types are the keys and the module data are the values.
 * @private
 */
var extractTopModules = exports.extractTopModules = function extractTopModules(moduleTree) {
  return Object.keys(moduleTree).reduce(function (topModules, moduleId) {
    var module = moduleTree[moduleId];
    var price_xp = module.price_xp,
        type = module.type;


    if (!topModules[type] || price_xp > topModules[type].price_xp) {
      // eslint-disable-line camelcase, max-len
      return _extends({}, topModules, {
        [type]: module
      });
    }

    return topModules;
  }, {});
};

/**
 * Localizes a slug using values returned from an API endpoint.
 * @param {Object} params - The function parameters.
 * @param {string} params.method - The API method which returns the localization data.
 * @param {string} params.type - The type of slug being localized.
 * @param {string} params.slug - The slug being localized.
 * @returns {Promise.<(string|undefined), Error>} Promise resolving to the
 *   translated slug, or `undefined` if it couldn't be translated.
 * @this {ClientModule}
 * @private
 */
var localize = exports.localize = function localize(_ref3) {
  var method = _ref3.method,
      type = _ref3.type,
      slug = _ref3.slug;

  return this.client.get(method, {}).then(function (response) {
    var translations = response.data[type];

    if (!translations || typeof translations !== 'object') {
      throw new Error(`Invalid translation type: ${type}.`);
    }

    return translations[slug];
  });
};